<!DOCTYPE html>
<html lang="">
<head>
    {% set height = bit_end - bit_start + 1 %}
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: scroll;
        }
        .img-display, .label-time-wrapper {
            display: flex;
        }
        .input-img {
            height: {{ height * pixel_scale }}px;
        }
        .pixel, .selection {
            position: absolute;
            z-index: 1;
        }
        .pixel {
            height: {{ pixel_scale }}px !important;
            width: {{ pixel_scale }}px !important;
            display: block;
        }
        .selection {background-color: rgba(0, 255, 0, 0.2);}
        .label-bit-wrapper {
            position: absolute;
            width: {{ 5 * pixel_scale }}px;
            color: red;
            text-shadow: 1px 1px 2px black;
            z-index: 2;
            user-select: none;
        }
        .label-bit {
            margin-bottom: {{ 4 * pixel_scale }}px;
            line-height: {{ pixel_scale }}px;
            font-size: {{ 1.5 * pixel_scale }}px;
        }
        .label-bit:last-child {margin-bottom: 0;}
        .label-bit::after {content: " -"}
        .label-time {
            display: inline-table;
            width: {{ 10 * pixel_scale }}px;
            margin-top: {{ pixel_scale }}px;
        }
        .label-time::before {
            content: "-";
            position: absolute;
            transform: rotate(90deg) translate(-28px, -4px);
            color: red;
            text-shadow: 1px 1px 3px black;
            font-size: {{ 4 * pixel_scale }}px;
        }
        .output {
            width: 50vw;
            position: absolute;
        }
        img {
            image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
            image-rendering: -moz-crisp-edges;          /* Firefox                        */
            image-rendering: -o-crisp-edges;            /* Opera                          */
            image-rendering: pixelated; /* Chrome */
            -ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */
        }
    </style>
    <title>Tool</title>
</head>
<body>
    <div class="img-container">
        <div class="pixel" id="mouse"></div>
        <div class="pixel" id="mouse2"></div>
        <div class="selection" id="selection"></div>
        <div class="label-bit-wrapper">
            {% for val in range(bit_start, bit_end + 1, 5) %}
            <div class="label-bit">{{ val }}</div>
            {% endfor %}
        </div>
        <div class="img-display">
            <img src="{{ img }}" class="input-img" style="display: inline" alt="">
        </div>
    </div>
    <div class="label-time-wrapper"></div>
    <div class="output">
        Bit range: <span id="bit-start"></span> - <span id="bit-end"></span><br/>
        Time: <span id="time-start"></span> - <span id="time-end"></span><br/>
        <a href="#" id="submit-link">Submit</a>
    </div>
    <script>
        const time_start = {{ time_start }}
        const time_end = {{ time_end }}
        const pixelScale = {{ pixel_scale }}
        const bit_start = {{ bit_start }}
        const bit_end = {{ bit_end }}
        const bitRange = {{ height }}
        const img = document.querySelector('.input-img')
        const imgContainer = document.querySelector('.img-container')
        const div1 = document.getElementById('mouse')
        const div2 = document.getElementById('mouse2')
        const selection = document.getElementById('selection')
        const bitStart = document.getElementById('bit-start')
        const bitEnd = document.getElementById('bit-end')
        const timeStart = document.getElementById('time-start')
        const timeEnd = document.getElementById('time-end')
        const submitA = document.getElementById('submit-link')
        let selecting = false;

        function set_pixel_pos(div, event) {
            const clientX = event.clientX + window.scrollX
            const clientY = event.clientY + window.scrollY
            div.style.left = `${clientX - (clientX % pixelScale)}px`
            div.style.top = `${Math.min(clientY - (clientY % pixelScale), (bitRange - 1) * pixelScale)}px`
        }

        function parse_time(millisecond) {
            const hour = Math.trunc(millisecond / (60 ** 2) / 1000)
            millisecond %= 60 ** 2 * 1000
            const min = Math.trunc(millisecond / 60 / 1000)
            millisecond %= 60 * 1000
            const sec = Math.trunc(millisecond / 1000)
            millisecond %= 1000
            return `${hour}:${min}:${sec}.${String(millisecond).padEnd(3, '0')}`
        }

        function compute_output() {
            let { top, left, bottom, right } = selection.getClientRects()[0]
            left += window.scrollX
            right += window.scrollX
            top += window.scrollY
            bottom += window.scrollY

            let bit = {
                start: Math.trunc(top / pixelScale),
                end: Math.trunc(bottom / pixelScale - 1)
            }
            let time = {
                start: time_start + 200 * Math.trunc(left / pixelScale),
                end: time_start + 200 * Math.trunc(right / pixelScale - 1)
            }
            bitStart.innerText = String(bit.start)
            bitEnd.innerText = String(bit.end)
            timeStart.innerText = parse_time(time.start)
            timeEnd.innerText = parse_time(time.end)
            submitA.href = `/select?bit_start=${bit.start}&bit_end=${bit.end}&time_offset=${parse_time(time.start)}&time_end=${parse_time(time.end)}`
        }

        document.onclick = function (e) {
            if (imgContainer !== e.target && !imgContainer.contains(e.target)) {
                return
            }
            if (!selecting) {
                set_pixel_pos(div1, e)
                selection.style.width = '0px'
            } else {
                set_pixel_pos(div2, e)
                show_selection()
                compute_output()
            }
            selecting = !selecting
        }

        document.onmousemove = function (e) {
            if (selecting) {
                set_pixel_pos(div2, e)
                show_selection()
            }
        }
        document.onscroll = function () {
            document.querySelector('.label-bit-wrapper').style.left =
                document.querySelector('.output').style.left = window.scrollX + 'px'
        }

        function show_selection () {
            let top1 = parseInt(div1.style.top);
            let top2 = parseInt(div2.style.top);
            if (top1 > top2) {
                [top1, top2] = [top2, top1]
            }
            let left1 = parseInt(div1.style.left);
            let left2 = parseInt(div2.style.left);
            if (left1 > left2) {
                [left1, left2] = [left2, left1]
            }
            selection.style.top = `${top1}px`
            selection.style.left = `${left1}px`

            selection.style.height = `${top2 - top1 + pixelScale}px`
            selection.style.width = `${left2 - left1 + pixelScale}px`
        }

        (function add_time_label() {
            const timeWrapper = document.querySelector('.label-time-wrapper')
            const imgWidth = img.width
            let html = '';
            let time = time_start;

            if (imgWidth === 0) {
                setTimeout(add_time_label)
                return
            }

            const offset = 1000 - time % 1000
            html += `<div style="height: ${pixelScale}px; width: ${offset / 200 * pixelScale}px; display: inline-table "></div>`
            time += offset

            while ((time - time_start) / 100 * 5 < imgWidth) {
                html += `<span class="label-time">${parse_time(time)}</span>`
                time += 2000
            }
            timeWrapper.innerHTML = html
        })();

        (function show_output_labels () {
            bitStart.innerText = String(bit_start)
            bitEnd.innerText = String(bit_end)
            timeStart.innerText = parse_time(time_start)
            timeEnd.innerText = parse_time(time_end)
        })()
    </script>
</body>
</html>